ggplot(data4 ,aes(x=sales,y=hat,color=store_id))+
geom_point()+ geom_abline(slope=1,intercept=0)+ggthemes::theme_tufte()+
ggtitle("Predicted vs Actual",subtitle="store 170 looks a bit off . . .")
#plot decomp
fin_pred<-get_predictors_vector(recipe3)
names(fin_pred)<-NULL
decomps<-get_decomps_linear() %>%rowwise() %>%  mutate(media=sum(c_across(all_of(fin_pred))))
decomps$week<-data1$week
decomps$sales<-data1$sales
decomps<-get_decomps_linear() %>%rowwise() %>%  mutate(media=sum(c_across(all_of(fin_pred))))
rethinking_results@coef
modeled_data=data3
model_coefs=rethinking_results@coef
predictors=get_predictors_vector(recipe3)
#for now, ignore [bracket] codefs
model_coefs<-model_coefs[names(model_coefs) %in% paste0("b_",predictors)]
predictors
#order them by final_predictors order
model_coefs<-model_coefs[order(factor(names(model_coefs),levels=paste0("b_",predictors)))]
model_coefs
matrix_data<-modeled_data %>% select(all_of(predictors) )%>% as.matrix()
matrix_data<-modeled_data %>% ungroup() %>% select(all_of(predictors) )%>% as.matrix()
for (i in 1:nrow(matrix_data)){
matrix_data[i,]<-matrix_data[i,]*model_coefs
}
decomps<-as_tibble(matrix_data)
names(decomps)<-predictors
rethinking_results@model
rethinking_results@call
rethinking_results@formula
link
link.fit
showMethods('link')
link.ulam
getMethod('link','ulam')
?getMethod
link_ulam
rethinking_results@formula_parsed$link_funcs
fit<-rethinking_results
names(fit@formula_parsed$link_funcs)
model_obj=rethinking_results
ff<-fit@formula_parsed
ff$marginalize_bank
ff$symbol_graph
ff$symbols
ff$impute_bank
ff$indices
ff$formula
links<-model_obj@formula_parsed$link_funcs
links
links[[1]]
links[[1]]$func
str(links[[1]]$func)
link(rethinking_results,n=1)
get_predictors(recipe3)
get_predictors_vector(recipe3)
predictors=get_predictors_vector(recipe3))
predictors=get_predictors_vector(recipe3)
data_to_use=data3
model_obj=rethinking_results
#make a list of data_to_use versions -- one with each predictor set to 0
variations<-vector('list',length=length(predictors))
variations<-vector('list',length=length(predictors))
for(i in 1:length(variations)){
variations[[i]]<-data_to_use
variations[[i]][predictors[i]]<-0
}
names(variations)<-predictors
predictors[1]
variations['price']
range(variations['price']$price)
range(variations['price'] %>% select(price) %>% unlist())
pp<-variations['price']
pp<-variations[['price']]
range(pp$price)
lapply(variations,function(x) {colMeans(link(model_obj,x,n=1000)$big_model)})
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=1000)$big_model)})
preds_base<-colMeans(link(model_obj,data_to_use,n=1000)$big_model)
preds_base
#this initial delta will be not additive if model is mutiplicative
decomps_0<-lapply(preds_variations,function(x) preds_base-x)
decomps_0
as_tibble(decomps_0)
as_tibble(decomps_0)$price[208]
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=sum(all_numeric())
#sum decomps_0 . . .
decomps_0_tots<-lapply(preds_variations)
links<-model_obj@formula_parsed$link_funcs
#for now, ignore [bracket] codefs
model_coefs<-model_coefs[names(model_coefs) %in% paste0("b_",predictors)]
#order them by final_predictors order
model_coefs<-model_coefs[order(factor(names(model_coefs),levels=paste0("b_",predictors)))]
matrix_data<-modeled_data %>% ungroup() %>% select(all_of(predictors) )%>% as.matrix()
for (i in 1:nrow(matrix_data)){
matrix_data[i,]<-matrix_data[i,]*model_coefs
}
decomps<-as_tibble(matrix_data)
names(decomps)<-predictors
return(decomps)
}
update_range_from_control<-function(parameter_set,controls){
for(i in 1:length(parameter_set$id)){
parameter_set$object[i][[1]]<-do.call(
unlist(controls[controls$dial_id==parameter_set$id[i],'dial_func']),
list(range=unlist(controls[controls$dial_id==parameter_set$id[i],'new_range']))
)
}
return(parameter_set)
}
create_dials_from_wf_and_controls<-function(workflow=mmm_wf,control_ranges=transform_controls){
tune_these_parms<-extract_parameter_set_dials(workflow) #will have default ranges
if(nrow(tune_these_parms)==0){return(tune_these_parms)}
#get ranges from transform_controls
gamma_ranges<-control_ranges %>%rowwise() %>%  mutate(dial_id=paste0(role,"_saturation_speed")) %>%
mutate(new_range=map2(list(saturation_speed_low),list(saturation_speed_high),~c(.x,.y)),
dial_func='saturation_speed') %>% select(dial_id,new_range,dial_func)
alpha_ranges<-control_ranges %>%rowwise() %>%  mutate(dial_id=paste0(role,"_asymptote")) %>%
mutate(new_range=map2(list(asymptote_low),list(asymptote_high),~c(.x,.y)),dial_func='asymptote') %>% select(dial_id,new_range,dial_func)
retention_ranges<-control_ranges %>%rowwise() %>%  mutate(dial_id=paste0(role,"_retention")) %>%
mutate(new_range=map2(list(retention_low),list(retention_high),~c(.x,.y)),dial_func='retention') %>% select(dial_id,new_range,dial_func)
tune_these_parms<-update_range_from_control(tune_these_parms,rbind(gamma_ranges,alpha_ranges,retention_ranges))
return(tune_these_parms)
}
tune_or_fetch_hyperparameters<-function(tune_this_time,saved_parameter_RDS=NULL,recipe_to_use=recipe3,
model_formula=built_formula,data_set=data1,control_ranges=transform_controls){
if(tune_this_time){
#unforutnately, lmer won't run without a random effect in the model formula
if(grepl("\\|",model_formula)){tune_spec<-linear_reg(engine='lmer')} else{
tune_spec<-linear_reg(engine='lm')}
#  hardhat::extract_parameter_set_dials(reg_wf)%>% finalize(data1)
#need to build a formula with random effects specs for stan_glmer
mmm_wf<-workflow() %>%  add_recipe(recipe_to_use) %>%
add_model(tune_spec,formula=as.formula(model_formula))
# #testing if stan spec is rigth:
# best_mmm<-finalize_workflow(mmm_wf,final_hypers)
#
# fit(best_mmm,data1)
#going to stratfiy on store to make sure time series terms aren't stupid . . . ?
folds<-vfold_cv(data_set,v=5,strata=store,pool=0.001)
#try to tune .  . . fingers crossed!
#get parameters (if tunable methods correctly working this will be all that's needed)
tune_these_parms<-create_dials_from_wf_and_controls(workflow=mmm_wf,control_ranges=control_ranges)
#TODO:: add parallel option?
#create cluster handle
# this_cl<-parallel::makeCluster(8)
#make list of variables to copy to each worker:
# big_var_list<-c(lsf.str(),'new_quant_param','data1','priors_to_add',
#                 'inject_this_for_signs')
# vars_that_we_need<-c(big_var_list[big_var_list %in% ls()],'new_quant_param')
#
# parallel::clusterExport(this_cl,varlist=vars_that_we_need)
# doParallel::registerDoParallel(this_cl)
if(nrow(tune_these_parms)>0){
tuning_trials<- tune_bayes(
mmm_wf,
resamples = folds,
initial=length(tune_these_parms$id)*2,
#grid=20,
param_info = tune_these_parms
)
# parallel::stopCluster(this_cl)
# final_hypers<-readRDS('best_hypers_b2.RDS')
final_hypers<-select_best(tuning_trials)
}else{
final_hypers=tibble()
}
#see what this looks like
#get groups --
groupings=as.character(groups(data_set))
time_var<-summary(recipe_to_use) %>% filter(role=='time_id') %>% select(variable) %>% unlist()
sort_vars<-c(groupings,time_var)
best_mmm<-finalize_workflow(mmm_wf ,final_hypers)  %>% fit(data_set %>% group_by(across(all_of(groupings))) %>%
arrange(across(all_of(sort_vars))))
# data_set<-data_set %>%  arrange(across(all_of(sort_vars))) %>% group_by(across(all_of(groupings)))
# best_mmm<-fit(best_mmm,data_set)
#
# fit(best_mmm,data1)
#saveRDS(best_mmm,'best_mmm_b3.RDS')
saveRDS(final_hypers,saved_parameter_RDS)
return(final_hypers)
}else{
return(readRDS(saved_parameter_RDS))
}
}
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=sum(all_numeric))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=sum(all_numeric()))
decomps_0$decomp_tot
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=sum(all_of(!!predictors)))
predictors
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=sum(all_of(predictors)))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSums)
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSums(.))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSums(.[1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSum(.[1:length(predictors)]))
rlang::last_trace()
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSums(.[1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=rowSums(.[1:5]))
rlang::last_trace()
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
rowwise() %>% mutate(decomp_tot=list(rowSums(.[1:5])))
View(decomps_0)
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
ungroup() %>% mutate(decomp_tot=rowSums(.[1:5]))
View(decomps_0)
fwrite(decomps_0,'decomps_0.csv')
data.table::fwrite(decomps_0,'decomps_0.csv')
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums(.[1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums(.[1:length(predictors)]))
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums(.[1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums(_[1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums([1:length(predictors)]))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums())
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup() |> mutate(decomp_tot=rowSums(_))
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) %>%
ungroup()
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_base-x)) |>
ungroup()
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
data.table::fwrite(decomps_0,"decomps_0.csv")
decomps_0$delta<-decomp0_tot-preds_base
decomps_0$delta<- decomps_0$decomp0_tot-preds_base
View(decomps_0)
predictors
built_formula
rethinking_results@formula
rethinking_results@data
rethinking_results@coef
predictors
preds_main<-colMeans(link(model_obj,data_to_use,n=1000)$big_model)
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_main-x)) |>
ungroup()
#intercept_only
data_to_use |>mutate(across(all_of(!!predictors),0))
#intercept_only
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 ))
int_only_preds<-colMeans(link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)$big_model)
int_only_preds
decomps_0$int_only<-int_only_preds
decomps0
decomps_0
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_main-x)) |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$int_only<-int_only_preds
decomps_0$delta<- decomps_0$decomp0_tot + decomps_0$int_only-preds_base
View(decomps_0)
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_main-x)) |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$int_only<-int_only_preds
decomps_0$preds_base=preds_base
decomps_0$delta<- decomps_0$decomp0_tot + decomps_0$int_only-preds_base
View(decomps_0)
#this initial delta will be not additive if model is mutiplicative
decomps_0<-as_tibble(lapply(preds_variations,function(x) preds_main-x)) |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$int_only<-int_only_preds
decomps_0$preds_base=preds_main
decomps_0$delta<- decomps_0$decomp0_tot + decomps_0$int_only-preds_main
decomps_0
preds_base
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) preds_main-x)
list_decomps_0
int_only_preds
View(data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 ))
)
View(data_to_use %>% mutate(across(all_of(!!predictors),function(x) 0 ))
)
View(data_to_use %>% mutate(across(all_of(!!predictors),function(x) rep(0,length(x)) )))
View(data_to_use |>mutate(across(all_of(!!predictors),function(x) {0 })))
data_to_use %>% mutate(price=0)
View(data_to_use |>mutate(across(all_of(!!predictors),function(x) {0 })))
data_to_use |> mutate(across(all_of('price'),0))
data_to_use |> mutate(across(all_of('price'),function(x) 0))
data_to_use |> mutate(across(all_of('price'),function(x) 0))
predicgtors
predictors
data_to_use |> mutate(across(all_of(!!predictors),function(x) 0))
data_to_use |> mutate(across(all_of(c("price","TV1")),function(x) 0))
data_to_use |> mutate(across(all_of(c("price","TV1","trend")),function(x) 0))
predictors
data_to_use |> mutate(across(all_of(!!predictors),function(x) 0))
names(predictors)<-NULL
data_to_use |> mutate(across(all_of(!!predictors),function(x) 0))
get_predictors_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time')) |> select(variable))
predictors<-unlist(summary(base_recipe) |>
filter(role=='predictor') |> select(variable))
names(predictors)<-NULL
return(predictors[!(predictors %in% groups_and_time)])
}
predictors=get_predictors_vector(recipe3)
int_only_preds<-colMeans(link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)$big_model)
int_only_preds
list_decomps_0<-lapply(preds_variations,function(x) preds_main-x)
decomps_0<-as_tibble() |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$int_only<-int_only_preds
decomps_0$preds_base=preds_main
decomps_0$delta<- decomps_0$decomp0_tot + decomps_0$int_only-preds_main
decomps_0
list_decomps_0<-lapply(preds_variations,function(x) preds_main-x)
decomps_0<-as_tibble() |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0
variations<-vector('list',length=length(predictors))
for(i in 1:length(variations)){
variations[[i]]<-data_to_use
variations[[i]][predictors[i]]<-0
}
names(variations)<-predictors
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_main<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
preds_main
preds_variations$price
int_only_preds<-colMeans(link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)$big_model)
int_only_preds
list_decomps_0<-lapply(preds_variations,function(x) preds_main-x)
decomps_0<-as_tibble() |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0<-as_tibble(list_decomps_0) |>
ungroup()
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) preds_main-x)
decomps_0<-as_tibble(list_decomps_0) |>
ungroup()
#sum decomps_0 . . .
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0
decomps_0$int_only<-int_only_preds
decomps_0$int_only<-int_only_preds-preds_main
decomps_0$int_only
decomps_0$price[1]
decomps_0[1,]
decomps_0$int_only<-preds_main-int_only_preds
decomps_0[1,]
decomps_0$preds_base=preds_main
decomps_0[1,]
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) int_only_preds-x)
decomps_0<-as_tibble(list_decomps_0) |>
ungroup()
list_decomps_0<-lapply(preds_variations,function(x) int_only_preds-x)
decomps_0<-as_tibble(list_decomps_0)
decomps_0
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-int_only_preds)
decomps_0<-as_tibble(list_decomps_0)
decomps_0
int_only_preds
model_obj@coef
model_obj@coef$a0+model_obj@coef$store_int[1]
model_obj@coef$a0
model_obj@coef['a0']
model_obj@coef['a0']+model_obj@coef['store_int[1]']
model_obj@coef['a0']+model_obj@coef['store_int[2]']
link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)$big_model
View(data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )))
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)
names(fff)
fff$big_model
mean(fff$big_model[,208])
mean(fff$big_model[,206])
mean(fff$big_model[,30])
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=1
)
mean(fff$big_model[,30])
mean(fff$big_model[,206])
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 ))
)
fff
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 ))
n=1e6
)
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=1e6
)
fff
mean(fff$big_model[,206])
dim(fff$big_model)
link(rethinking_results)
fff<-link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )) %>% head()
)
fff
fff$big_model
colMeans(fff$big_model)
int_only_preds<-colMeans(link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 100 )),
n=sample_size
)$big_model)
int_only_preds
int_only_preds<-colMeans(link(model_obj,
data_to_use |>mutate(across(all_of(!!predictors),function(x) 0 )),
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-int_only_preds)
list_decomps_0$price
variations$price$price
preds_variations$price
int_only_preds
onerow<-data_to_use[3,0]
onerow
onerow<-data_to_use[3,]
onerow
link(model_obj,onerow)
link(model_obj,onerow)$big_model
colMeans(link(model_obj,onerow)$big_model)
model_obj@coef['price']
model_obj@coef
-4.2340220*onerow$price
int_only_preds[3]
preds_variations$price[3] - int_only_preds[3]
preds_variations$price[3]
variations$price[3,'price']
preds_main[3]
preds_variations$price[3]
preds_variations$price[3]-preds_main[3]
int_only_preds[3]
names(data_to_use)
names(data_to_use)[grepl("_id",names(data_to_use)))]
names(data_to_use)[grepl("_id",names(data_to_use))]
int_off_preds<-colMeans(link(model_obj,
data_to_use |>
mutate(across(all_of(names(data_to_use)[grepl("_id",names(data_to_use))]),function(x) 0 )),
n=sample_size
)$big_model)
data_to_use |>
mutate(across(all_of(names(data_to_use)[grepl("_id",names(data_to_use))]),function(x) 0 ))
View(data_to_use |>
mutate(across(all_of(names(data_to_use)[grepl("_id",names(data_to_use))]),function(x) 0 )))
int_off_preds<-colMeans(link(model_obj,
data_to_use |>
mutate(across(all_of(names(data_to_use)[grepl("_id",names(data_to_use))]),function(x) 3 )),
n=sample_size
)$big_model)
devtools::install_github("rmcelreath/rethinking",force=T)
