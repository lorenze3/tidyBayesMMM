decomps<-get_decomps_irregardless() %>%rowwise() %>%  mutate(media=sum(c_across(all_of(fin_pred))))
#plot decomp
fin_pred<-get_predictors_vector(recipe3)
names(fin_pred)<-NULL
decomps<-get_decomps_irregardless() %>%rowwise() %>%
mutate(media=sum(c_across(all_of(fin_pred))))
decomps<-get_decomps_irregardless() %>%rowwise() %>%
mutate(media=sum(c_across(all_of(!!fin_pred))))
decomps<-get_decomps_irregardless()
names(decomps)
names(variations)<-predictors
model_obj
chain_ids(model_obj)
link_ulam(model_obj,data3)
data_to_use$store_id<-0
link_ulam(model_obj,data_to_use)
link(model_obj,data_to_use)
#for linear models, this is just coef* ind_var
#same process though will work for multiplicative models, with drivers workin gas
#lift*base - base, and then the total rescaled to match the total prediction
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
data_to_use=data3
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
decomps_1
predictors
get_groups_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time')) |> select(variable))
predictors<-unlist(summary(base_recipe) |>
filter(role=='predictor') |> select(variable))
names(predictors)<-NULL
return(groups_and_time[!(groups_and_time %in% predictors)])
}
get_groups_vector()
base_recipe=recipe3
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time')) |> select(variable))
groups_and_time
predictors<-unlist(summary(base_recipe) |>
filter(role=='predictor') |> select(variable))
predictors
View(summary(base_recipe))
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time_id')) |> select(variable))
get_groups_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time_id')) |> select(variable))
return(groups_and_time)
}
get_groups_vector()
#'pulls vector of identification variables from recipe using role== group or role==time_id
#'@param base_recipe defaults to recipe3; a recipe produced in the mostlytidyMMM format
#'@return
#' a character vector
#' @example
#' @export
#' @importFrom dplyr filter
get_id_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time_id')) |> select(variable))
return(groups_and_time)
}
get_id_vector()
#'pulls vector of identification variables from recipe using role== group or role==time_id
#'@param base_recipe defaults to recipe3; a recipe produced in the mostlytidyMMM format
#'@return
#' a character vector
#' @example
#' @export
#' @importFrom dplyr filter
get_id_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('group','time_id')) |> select(variable))
names(groups_and_time)<-NULL
return(groups_and_time)
}
get_id_vector()
recipe_to_use=recipe3
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
#to make sure output is clear, need to rename these to decomps_
#append the columns in data_to_use that are not in decomps_1
cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
decomps_1)
decomps_1<-cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
decomps_1)
names(decomps_1)
get_id_vector(recipe_to_use)
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
names(decomps_1)
#get decomps (assume linear model)
get_decomps_irregardless<-function(data_to_use=data3,recipe_to_use=recipe3,model_obj=rethinking_results,
predictors=get_predictors_vector(recipe3),sample_size=1000){
#for linear models, this is just coef* ind_var
#same process though will work for multiplicative models, with drivers workin gas
#lift*base - base, and then the total rescaled to match the total prediction
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
#to make sure output is clear, need to rename these to decomps_
#append the columns in data_to_use that are not in decomps_1
decomps_1<-cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
decomps_1)
return(decomps_1)
}
decomps<-get_decomps_irregardless()
names(decomps)
fin_pred
decomps<-get_decomps_irregardless() %>%rowwise() %>%
mutate(media=sum(c_across(all_of(!!fin_pred))))
decomps$week<-data1$week
decomps$sales<-data1$sales
decomps$base<-decomps$sales-decomps$media
decomps<-get_decomps_irregardless() %>%rowwise() %>%
mutate(media=sum(c_across(all_of(!!fin_pred))))
decomps
decomps$sales<-data4$sales
get_outcome_vector<-function(base_recipe=recipe3){
groups_and_time<-unlist(summary(base_recipe) |> filter(role %in% c('outcome')) |> select(variable))
names(groups_and_time)<-NULL
return(groups_and_time)
}
get_outcome_vector()
#get decomps (assume linear model)
get_decomps_irregardless<-function(data_to_use=data3,recipe_to_use=recipe3,model_obj=rethinking_results,
predictors=get_predictors_vector(recipe3),sample_size=1000){
#for linear models, this is just coef* ind_var
#same process though will work for multiplicative models, with drivers workin gas
#lift*base - base, and then the total rescaled to match the total prediction
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
#to make sure output is clear, need to rename these to decomps_
#append the columns in data_to_use that are not in decomps_1
decomps_1<-cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
data_to_use %>% select(all_of(get_outcome_vector(recipe_to_use))),
decomps_1)
return(decomps_1)
}
decomps<-get_decomps_irregardless()
View(decomps)
decomps_natl<-decomps %>% group_by(week) %>% summarise(across(where(is.numeric),sum))
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week,-sales,-media))
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week,-sales,-store,-product)
)
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week,-sales,-store,-product))
decomps_natl<-decomps %>% group_by(week) %>% summarise(across(where(is.numeric),sum))
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week,-sales))
ggplot(data=decomps_natl,aes(x=week,y=value,fill=name)) + geom_area()+ggthemes::theme_tufte()+
ggtitle("Decomposition By Week")+
theme(legend.position = 'bottom')
decomps_natl<-decomps %>% select(week,all_of(!!fin_pred)) %>% group_by(week) %>% summarise(across(where(is.numeric),sum))
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week)
ggplot(data=decomps_natl,aes(x=week,y=value,fill=name)) + geom_area()+ggthemes::theme_tufte()+
ggtitle("Decomposition By Week")+
theme(legend.position = 'bottom')
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week))
ggplot(data=decomps_natl,aes(x=week,y=value,fill=name)) + geom_area()+ggthemes::theme_tufte()+
ggtitle("Decomposition By Week")+
theme(legend.position = 'bottom')
names(decomps)
decomps<-get_decomps_irregardless() %>% mutate(residual=sales-pred)
decomps_natl<-decomps %>% select(week,all_of(!!fin_pred),residual) %>% group_by(week) %>% summarise(across(where(is.numeric),sum))
decomps_natl<-decomps_natl %>% pivot_longer(cols=c(-week))
ggplot(data=decomps_natl,aes(x=week,y=value,fill=name)) + geom_area()+ggthemes::theme_tufte()+
ggtitle("Decomposition By Week")+
theme(legend.position = 'bottom')
ggplot(data4 ,aes(x=sales,y=hat,color=store_id))+
geom_point()+ geom_abline(slope=1,intercept=0)+ggthemes::theme_tufte()+
ggtitle("Predicted vs Actual")
#' get decomps agnostic to multiplicative or additive model specification
#'
#'@param data_to_use defaults to data 3; a transformed dataset (likely produced via bake())
#'@param recipe_to_use defaults to recipe3; a recipe which has the roles assigned for the MMM
#'@param model_obj defaults to rethinking_results; an ulam fit object
#'@param predictors defaulst to get_predictors(recipe3)
get_decomps_irregardless<-function(data_to_use=data3,recipe_to_use=recipe3,model_obj=rethinking_results,
predictors=get_predictors_vector(recipe_to_use),sample_size=1000){
#for linear models, this is just coef* ind_var
#same process though will work for multiplicative models, with drivers workin gas
#lift*base - base, and then the total rescaled to match the total prediction
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
#to make sure output is clear, need to rename these to decomps_
#append the columns in data_to_use that are not in decomps_1
decomps_1<-cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
data_to_use %>% select(all_of(get_outcome_vector(recipe_to_use))),
decomps_1)
return(decomps_1)
}
rm(recipe_to_use)
decomps<-get_decomps_irregardless() %>% mutate(residual=sales-pred)
recipe6<-recipe_finalized
recipe6<-recipe_finalized %>% step_select(-product)
decomps<-get_decomps_irregardless(recipe_to_use=recipe6) %>% mutate(residual=sales-pred)
recipe6<-recipe_finalized %>% step_select(-week)
decomps<-get_decomps_irregardless(recipe_to_use=recipe6) %>% mutate(residual=sales-pred)
decomps<-get_decomps_irregardless(recipe_to_use=recipe_finalized) %>% mutate(residual=sales-pred)
decomps<-get_decomps_irregardless(data_to_use = data3, recipe_to_use=recipe_finalized) %>% mutate(residual=sales-pred)
decomps<-get_decomps_irregardless(data_to_use = data3, recipe_to_use=recipe3) %>% mutate(residual=sales-pred)
recipe_finalized
summary(recipe_finalized)
View(summary(recipe_finalized))
View(summary(recipe3))
recipe_to_use=finalized_recipe
recipe_to_use=recipe_finalized
get_predictors_vector(recipe_to_use)
?ulam
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- b_x[store_id]*x,
bx[store_id] ~ normal(1.5,.25)
),
data=tib,
chains=1,sample=T
)
library(rethinking)
tib<-tibble(store_id=c(1,1,1,2,2,2),
y=c(0,1,2,0,2,4),
x=c(0,1,2,0,1,2))
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- b_x[store_id]*x,
bx[store_id] ~ normal(1.5,.25)
),
data=tib,
chains=1,sample=T
)
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- bx[store_id]*x,
bx[store_id] ~ normal(1.5,.25)
),
data=tib,
chains=1,sample=T
)
ulam_obj
ulam_obj@coef
new_tib<-tibble(x=3,4)
new_tib<-tibble(x=c(3,4))
link(ulam_obj)
link(ulam_obj,new_tib)
library(rethinking)
tib<-tibble(store_id=c(1,1,1,2,2,2),
y=c(0,1,2,0,2,4),
x=c(0,1,2,0,1,2))
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- bx[store_id]*x +b *x,
bx[store_id] ~ normal(0,.5),
b ~normal(1.5,.00001)
),
data=tib,
chains=1,sample=T
)
new_tib<-tibble(x=c(3,4))
link(ulam_obj)
link(ulam_obj,new_tib)
ulam_obj@coef
ulam_obj@coef
ulam_obj@formula
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- (bx[store_id] +b )*x,
bx[store_id] ~ normal(0,.5),
b ~ normal(1.5,.00001)
),
data=tib,
chains=1,sample=T,iter=50
)
ulam_obj@call
ulam_obj@formula_parsed
ulam_obj@coef
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- (bx[store_id] +b )*x,
bx[store_id] ~ normal(0,.5),
b ~ normal(1.5,.00001)
),
file='testing_id.RDS'
data=tib,
chains=1,sample=T,iter=50
)
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- (bx[store_id] +b )*x,
bx[store_id] ~ normal(0,.5),
b ~ normal(1.5,.00001)
),
file='testing_id.RDS',
data=tib,
chains=1,sample=T,iter=50
)
ulam_obj@coef
rethinking_results@coef
rethinking_results@formula
link(ulam_obj)
link(ulam_obj,new_tib)
new_tib1<-tibble(store_id=c(1,1),x=c(3,4))
link(ulam_obj,new_tib)
new_tib1<-tibble(store_id=c(1,1),x=c(3,4))
link(ulam_obj,new_tib1)
new_tib2<-tibble(store_id=c(2,2),x=c(3,4))
link(ulam_obj,new_tib2)
new_tib<-tibble(store_id=c(0,0),x=c(3,4))
link(ulam_obj,new_tib)
library(rethinking)
tib<-tibble(store_id=c(1,1,1,2,2,2),
y=c(0,1,2,0,2,4),
x=c(0,1,2,0,1,2))
ulam_obj<-ulam(
alist(y~normal(product,.0000001),
product<- (bx[store_id] +b )*x,
bx[store_id] ~ normal(0,1),
b ~ normal(1.5,.00001)
),
file='testing_id.RDS',
data=tib,
chains=1,sample=T,iter=50
)
new_tib1<-tibble(store_id=c(1,1),x=c(3,4))
new_tib2<-tibble(store_id=c(2,2),x=c(3,4))
new_tib0<-tibble(store_id=c(0,0),x=c(3,4))
link(ulam_obj,new_tib1)
link(ulam_obj,new_tib2)
#this one errors:
link(ulam_obj,new_tib0)
#as does
new_tib<-tibble(x=c(3,4))
link(ulam_obj,new_tib)
get_predictors_vector(recipe_to_use)
model_obj
model_obj@coef
get_predictors(recipe_to_use)
get_predictors_vector(recipe_to_use)
predictors[!grepl("_id",predictors,fixed=T)]
predictors=get_predictors_vector(recipe_to_use)
predictors[!grepl("_id",predictors,fixed=T)]
get_decomps_irregardless<-function(data_to_use=data3,recipe_to_use=recipe_finalized,model_obj=rethinking_results,
predictors=get_predictors_vector(recipe_to_use),sample_size=1000){
#predictors will need to be trimmed of *_id variables (at least until we know how to predict with missinf id values)
predictors<-predictors[!grepl("_id",predictors,fixed=T)]
variations<-vector('list',length=length(predictors))
predictors_to_zero<-data_to_use |>
mutate(across(all_of(!!predictors),function(x) 0 ))
for(i in 1:length(variations)){
variations[[i]]<-predictors_to_zero
variations[[i]][predictors[i]]<-data_to_use[predictors[i]]
}
names(variations)<-predictors
decomp_names<-c(names(variations),"decomp_base")
preds_variations<-lapply(variations,function(x) {colMeans(link(model_obj,x,n=sample_size)$big_model)})
preds_all<-colMeans(link(model_obj,data_to_use,n=sample_size)$big_model)
#intercept_only
decomp_base<-colMeans(link(model_obj,
predictors_to_zero,
n=sample_size
)$big_model)
#this initial delta will be not additive if model is mutiplicative
list_decomps_0<-lapply(preds_variations,function(x) x-decomp_base)
decomps_0<-as_tibble(list_decomps_0)
#sum decomps_0 . . .
# decomps_0$int_only<-int_off_preds-preds_main
decomps_0$decomp_base=decomp_base
decomps_0$decomp0_tot<-rowSums(decomps_0,na.rm=T)
decomps_0$pred<-preds_all
decomps_0$decomp_ratio <-  decomps_0$pred/decomps_0$decomp0_tot
decomps_1<- decomps_0 |>mutate(across(all_of(!!decomp_names),function(x) x*decomp_ratio))
#to make sure output is clear, need to rename these to decomps_
#append the columns in data_to_use that are not in decomps_1
decomps_1<-cbind(data_to_use %>% select(all_of(get_id_vector(recipe_to_use))),
data_to_use %>% select(all_of(get_outcome_vector(recipe_to_use))),
decomps_1)
return(decomps_1)
}
decomps<-get_decomps_irregardless(data_to_use = data3, recipe_to_use=recipe3) %>% mutate(residual=sales-pred)
decomps
